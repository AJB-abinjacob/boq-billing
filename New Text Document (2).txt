Hereâ€™s your Master Instruction Prompt for an AI Agent to build the entire MERN BOQ billing app from scratch, with explanations of what, how, when, where, and why, designed to be crystal-clear for AI autopilot.

ðŸš€ Expert-Level Step-by-Step AI Prompt to Build MERN BOQ Billing App (Admin + User)
Objective:

Build a professional, scalable BOQ Billing web application using MERN stack, that supports:

Admin and User roles (without authentication for now)

Dynamic billing templates with customizable fields

Nested categories and products with full CRUD

Draft/finalized bills with statuses and export options (PDF/Excel/CSV)

Company branding with customizable PDF layouts

Responsive, enterprise-grade UI/UX

Real-time autosave and search/filter capabilities

Instructions to AI Agent: Step-by-step guide
PHASE 1: Backend Setup and Core Data Models
Step 1.1: Initialize Backend Environment

Create a Node.js project with Express server

Connect to MongoDB with Mongoose using env-configured local URI

Add middleware: CORS, body-parser, logging (morgan)

Setup error handling middleware for graceful API responses

Why: Provides foundation for secure, scalable REST APIs.

Step 1.2: Design Database Schema Models

Company

Fields: name (string), logo (file path or URL), branding (colors, fonts), PDF layout config (JSON object)

Purpose: Multi-company support, global branding

Category

Fields: name (string), parentCategoryId (self-reference for nesting)

Purpose: Support infinite nested product categories

Product

Fields: name, categoryId (ref), unit, rate, GST percentage, optional tax fields

BillTemplate

Fields: companyId, templateName, array of field definitions (with order, label, type, required flag, formulas)

Purpose: Allow admin to define different invoice/bill formats

FieldDefinition (embedded or separate collection)

Fields: label (string), dataType (text, number, date, dropdown), required (bool), order (int), customFormula (optional)

Bill

Fields: companyId, billNumber (auto-increment with customizable prefix), customer info (optional), array of line items, totals, status tag (Draft/Finalized/etc.), timestamps

Draft

Same structure as Bill, used for autosave and intermediate editing

Notification

Simple structure for reminders or alerts related to bills

Payment

Linked to Bill, records payment amount, date, method

Why: Structured data is essential for complex querying, integrity, and scalability.

Step 1.3: Implement CRUD API Endpoints

For each model, implement: Create, Read (single & list), Update, Delete endpoints

Implement nested category fetching with recursive population

Support file upload (logo) for Company using multer middleware

Implement custom routes for:

Bill autosave (save as draft)

Bill finalization (status change)

PDF layout config update

Search endpoint querying bills, products, and categories with filters/sorting

Why: Full API control allows frontend flexibility and future integrations.

PHASE 2: Admin Panel Frontend
Step 2.1: Project Setup and Layout

Setup React project with Tailwind CSS for responsive design

Setup React Router for admin routes under /admin

Implement sidebar navigation for: Companies, Categories, Products, Templates, Bills, Settings

Step 2.2: Company Management UI

Form to add/edit company details, upload logo

Interface to configure global branding (colors, fonts)

PDF layout designer UI: drag/drop sections like logo, bill title, fields, totals

Live preview panel reflecting changes immediately

Why: Empower admins to brand bills per company and control output format.

Step 2.3: Category & Product Management

Nested tree view for categories with CRUD controls (add/edit/delete, reorder)

Product list with CRUD, search, and filter by category

When adding/editing product, admin can set rate, GST, and other financial fields

Step 2.4: Bill Template Builder

Interface to create templates per company

Drag/drop fields to reorder and add new fields (text, number, dropdown)

Fields can be marked required/optional

Support custom formula fields (e.g., qty * rate)

Template preview updates in real time

Step 2.5: Notifications & Analytics (Basic)

Dashboard showing counts of drafts, unpaid bills

Simple charts for revenue, top products, GST collected

PHASE 3: User Billing Interface
Step 3.1: Bill Creation UI

Select company and bill template

Auto-apply company branding and PDF layout to screen

Dynamically generate form based on selected bill template fields

Support line items with inline editing and optional modal form entry

Auto-fill product details when selecting from product dropdown

Real-time calculation of totals, taxes, discounts based on formulas

Status tag management (Draft, Finalized, Paid, etc.)

Save draft automatically every few seconds and on manual save

Step 3.2: Bill History & Search

Paginated list of all bills and drafts per company

Full-text search and filters by status, date, customer name

Sorting by bill number, date, amount

Step 3.3: Export Functionality

Export finalized bills to PDF, Excel, CSV

PDF export uses company-specific branding and layout configuration

Use jsPDF or equivalent libraries for PDF generation

Use SheetJS (xlsx) for Excel and csv-writer for CSV

PHASE 4: Additional Features & Production Readiness
Step 4.1: Status Tags and Payment Tracking

Implement manual update of bill statuses

Allow recording of payments with amount, date, method linked to bills

Visual indicators for unpaid, partially paid, and paid bills

Step 4.2: Backup & Restore Data

Admin interface to export/import company data and bills as JSON or Excel

Scheduled backup scripts (optional for future)

Step 4.3: Testing & Documentation

Write unit tests for backend APIs (using Jest or Mocha)

Write integration tests for frontend components (React Testing Library)

Document all API endpoints using Swagger or Postman collection

Prepare README with setup and usage instructions

Best Practices & Meta-Guidelines for the AI Agent

Always validate all input data on backend and frontend

Implement pagination and indexing for list endpoints

Handle errors gracefully with clear, user-friendly messages

Modularize codebase: separate concerns and layers

Use environment variables for sensitive info

Commit code incrementally with descriptive messages

Write clean, commented, and maintainable code

Communicate progress and ask clarifying questions if ambiguous

Summary: Execution Flow for AI Agent

Setup backend environment and database connection

Define all Mongoose models and relations

Implement CRUD APIs for all core models

Setup frontend base project and routing

Build admin panel with company, categories, products, and templates management

Build user billing interface with dynamic form generation and autosave

Add export features and bill status management

Add notifications, analytics, and backup features

Test, document, and prepare for deployment

Ready to proceed autonomously and build the entire system from scratch, step-by-step, without code omissions.